{
  "version": 3,
  "sources": ["browser-external:module", "../../../../node_modules/.pnpm/@unocss+preset-icons@0.29.6/node_modules/@unocss/preset-icons/dist/fs.mjs", "../../../../node_modules/.pnpm/local-pkg@0.4.2/node_modules/local-pkg/index.mjs", "../../../../node_modules/.pnpm/local-pkg@0.4.2/node_modules/local-pkg/dist/shared.mjs"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"module\" has been externalized for browser compatibility. Cannot access \"module.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "import { promises } from 'fs';\nimport { isPackageExists, resolveModule } from 'local-pkg';\n\nconst _collections = {};\nconst isLegacyExists = isPackageExists(\"@iconify/json\");\nasync function loadCollectionFromFS(name) {\n  if (!_collections[name])\n    _collections[name] = task();\n  return _collections[name];\n  async function task() {\n    let jsonPath = resolveModule(`@iconify-json/${name}/icons.json`);\n    if (!jsonPath && isLegacyExists)\n      jsonPath = resolveModule(`@iconify/json/json/${name}.json`);\n    if (jsonPath) {\n      const icons = JSON.parse(await promises.readFile(jsonPath, \"utf8\"));\n      return icons;\n    } else {\n      return void 0;\n    }\n  }\n}\n\nexport { loadCollectionFromFS };\n", "import { dirname, join } from 'path'\nimport { existsSync, promises as fs, readFileSync } from 'fs'\nimport { createRequire } from 'module'\n\nexport { loadPackageJSON, isPackageListed } from './dist/shared.mjs'\n\nconst _require = createRequire(import.meta.url)\n\nexport function resolveModule(name, options) {\n  try {\n    return _require.resolve(name, options)\n  }\n  catch (e) {\n    return undefined\n  }\n}\n\nexport function importModule(path) {\n  return import(path).then((i) => {\n    if (i && i.default && i.default.__esModule)\n      return i.default\n    return i\n  })\n}\n\nexport function isPackageExists(name, options) {\n  return !!resolvePackage(name, options)\n}\n\nfunction getPackageJsonPath(name, options) {\n  const entry = resolvePackage(name, options)\n  if (!entry)\n    return\n\n  return searchPackageJSON(entry)\n}\n\nexport async function getPackageInfo(name, options) {\n  const packageJsonPath = getPackageJsonPath(name, options)\n  if (!packageJsonPath)\n    return\n\n  const pkg = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'))\n\n  return {\n    name,\n    version: pkg.version,\n    rootPath: dirname(packageJsonPath),\n    packageJsonPath,\n    packageJson: pkg,\n  }\n}\n\nexport function getPackageInfoSync(name, options) {\n  const packageJsonPath = getPackageJsonPath(name, options)\n  if (!packageJsonPath)\n    return\n\n  const pkg = JSON.parse(readFileSync(packageJsonPath, 'utf8'))\n\n  return {\n    name,\n    version: pkg.version,\n    rootPath: dirname(packageJsonPath),\n    packageJsonPath,\n    packageJson: pkg,\n  }\n}\n\nfunction resolvePackage(name, options = {}) {\n  try {\n    return _require.resolve(`${name}/package.json`, options)\n  }\n  catch {\n  }\n  try {\n    return _require.resolve(name, options)\n  }\n  catch (e) {\n    if (e.code !== 'MODULE_NOT_FOUND')\n      console.error(e)\n    return false\n  }\n}\n\nfunction searchPackageJSON(dir) {\n  let packageJsonPath\n  while (true) {\n    if (!dir)\n      return\n    const newDir = dirname(dir)\n    if (newDir === dir)\n      return\n    dir = newDir\n    packageJsonPath = join(dir, 'package.json')\n    if (existsSync(packageJsonPath))\n      break\n  }\n\n  return packageJsonPath\n}\n", "var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => {\n  return {\n    set _(value) {\n      __privateSet(obj, member, value, setter);\n    },\n    get _() {\n      return __privateGet(obj, member, getter);\n    }\n  };\n};\n\n// shared.ts\nimport { existsSync, promises as fs2 } from \"fs\";\n\n// node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js\nimport path2 from \"path\";\nimport { fileURLToPath as fileURLToPath2 } from \"url\";\n\n// node_modules/.pnpm/locate-path@7.1.1/node_modules/locate-path/index.js\nimport process2 from \"process\";\nimport path from \"path\";\nimport fs, { promises as fsPromises } from \"fs\";\nimport { fileURLToPath } from \"url\";\n\n// node_modules/.pnpm/yocto-queue@1.0.0/node_modules/yocto-queue/index.js\nvar Node = class {\n  value;\n  next;\n  constructor(value) {\n    this.value = value;\n  }\n};\nvar _head, _tail, _size;\nvar Queue = class {\n  constructor() {\n    __privateAdd(this, _head, void 0);\n    __privateAdd(this, _tail, void 0);\n    __privateAdd(this, _size, void 0);\n    this.clear();\n  }\n  enqueue(value) {\n    const node = new Node(value);\n    if (__privateGet(this, _head)) {\n      __privateGet(this, _tail).next = node;\n      __privateSet(this, _tail, node);\n    } else {\n      __privateSet(this, _head, node);\n      __privateSet(this, _tail, node);\n    }\n    __privateWrapper(this, _size)._++;\n  }\n  dequeue() {\n    const current = __privateGet(this, _head);\n    if (!current) {\n      return;\n    }\n    __privateSet(this, _head, __privateGet(this, _head).next);\n    __privateWrapper(this, _size)._--;\n    return current.value;\n  }\n  clear() {\n    __privateSet(this, _head, void 0);\n    __privateSet(this, _tail, void 0);\n    __privateSet(this, _size, 0);\n  }\n  get size() {\n    return __privateGet(this, _size);\n  }\n  *[Symbol.iterator]() {\n    let current = __privateGet(this, _head);\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n};\n_head = new WeakMap();\n_tail = new WeakMap();\n_size = new WeakMap();\n\n// node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js\nfunction pLimit(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError(\"Expected `concurrency` to be a number from 1 and up\");\n  }\n  const queue = new Queue();\n  let activeCount = 0;\n  const next = () => {\n    activeCount--;\n    if (queue.size > 0) {\n      queue.dequeue()();\n    }\n  };\n  const run = async (fn, resolve, args) => {\n    activeCount++;\n    const result = (async () => fn(...args))();\n    resolve(result);\n    try {\n      await result;\n    } catch {\n    }\n    next();\n  };\n  const enqueue = (fn, resolve, args) => {\n    queue.enqueue(run.bind(void 0, fn, resolve, args));\n    (async () => {\n      await Promise.resolve();\n      if (activeCount < concurrency && queue.size > 0) {\n        queue.dequeue()();\n      }\n    })();\n  };\n  const generator = (fn, ...args) => new Promise((resolve) => {\n    enqueue(fn, resolve, args);\n  });\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount\n    },\n    pendingCount: {\n      get: () => queue.size\n    },\n    clearQueue: {\n      value: () => {\n        queue.clear();\n      }\n    }\n  });\n  return generator;\n}\n\n// node_modules/.pnpm/p-locate@6.0.0/node_modules/p-locate/index.js\nvar EndError = class extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n};\nvar testElement = async (element, tester) => tester(await element);\nvar finder = async (element) => {\n  const values = await Promise.all(element);\n  if (values[1] === true) {\n    throw new EndError(values[0]);\n  }\n  return false;\n};\nasync function pLocate(iterable, tester, {\n  concurrency = Number.POSITIVE_INFINITY,\n  preserveOrder = true\n} = {}) {\n  const limit = pLimit(concurrency);\n  const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);\n  const checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);\n  try {\n    await Promise.all(items.map((element) => checkLimit(finder, element)));\n  } catch (error) {\n    if (error instanceof EndError) {\n      return error.value;\n    }\n    throw error;\n  }\n}\n\n// node_modules/.pnpm/locate-path@7.1.1/node_modules/locate-path/index.js\nvar typeMappings = {\n  directory: \"isDirectory\",\n  file: \"isFile\"\n};\nfunction checkType(type) {\n  if (Object.hasOwnProperty.call(typeMappings, type)) {\n    return;\n  }\n  throw new Error(`Invalid type specified: ${type}`);\n}\nvar matchType = (type, stat) => stat[typeMappings[type]]();\nvar toPath = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\nasync function locatePath(paths, {\n  cwd = process2.cwd(),\n  type = \"file\",\n  allowSymlinks = true,\n  concurrency,\n  preserveOrder\n} = {}) {\n  checkType(type);\n  cwd = toPath(cwd);\n  const statFunction = allowSymlinks ? fsPromises.stat : fsPromises.lstat;\n  return pLocate(paths, async (path_) => {\n    try {\n      const stat = await statFunction(path.resolve(cwd, path_));\n      return matchType(type, stat);\n    } catch {\n      return false;\n    }\n  }, { concurrency, preserveOrder });\n}\n\n// node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js\nvar toPath2 = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath;\nvar findUpStop = Symbol(\"findUpStop\");\nasync function findUpMultiple(name, options = {}) {\n  let directory = path2.resolve(toPath2(options.cwd) || \"\");\n  const { root } = path2.parse(directory);\n  const stopAt = path2.resolve(directory, options.stopAt || root);\n  const limit = options.limit || Number.POSITIVE_INFINITY;\n  const paths = [name].flat();\n  const runMatcher = async (locateOptions) => {\n    if (typeof name !== \"function\") {\n      return locatePath(paths, locateOptions);\n    }\n    const foundPath = await name(locateOptions.cwd);\n    if (typeof foundPath === \"string\") {\n      return locatePath([foundPath], locateOptions);\n    }\n    return foundPath;\n  };\n  const matches = [];\n  while (true) {\n    const foundPath = await runMatcher({ ...options, cwd: directory });\n    if (foundPath === findUpStop) {\n      break;\n    }\n    if (foundPath) {\n      matches.push(path2.resolve(directory, foundPath));\n    }\n    if (directory === stopAt || matches.length >= limit) {\n      break;\n    }\n    directory = path2.dirname(directory);\n  }\n  return matches;\n}\nasync function findUp(name, options = {}) {\n  const matches = await findUpMultiple(name, { ...options, limit: 1 });\n  return matches[0];\n}\n\n// shared.ts\nasync function loadPackageJSON(cwd = process.cwd()) {\n  const path3 = await findUp(\"package.json\", { cwd });\n  if (!path3 || !existsSync(path3))\n    return null;\n  return JSON.parse(await fs2.readFile(path3, \"utf-8\"));\n}\nasync function isPackageListed(name, cwd) {\n  const pkg = await loadPackageJSON(cwd) || {};\n  return name in (pkg.dependencies || {}) || name in (pkg.devDependencies || {});\n}\nexport {\n  isPackageListed,\n  loadPackageJSON\n};\n"],
  "mappings": "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",
  "names": ["import_fs", "import_path", "import_fs", "import_path", "import_fs", "import_url"]
}
